


comprehension
list, dict, set, generator

lambda

filter, map, reduce


###################################
zip and unzip functions

names = ['john', 'paul', 'dave']
comps = ['small', 'medium', 'large']
age = [72, 34, 67]

>>> list(zip(names,comps,age))    
[('john', 'small', 72), ('paul', 'medium', 34), ('dave', 'large', 67)]

>>> list(zip(names,comps))
[('john', 'small'), ('paul', 'medium'), ('dave', 'large')]

first_name = ['Joe','Earnst','Thomas','Martin','Charles']
last_name = ['Schmoe','Ehlmann','Fischer','Walter','Rogan','Green']
age = [23, 65, 11, 36, 83]

for first_name, last_name, age in zip(first_name, last_name, age):
    print(f"{first_name} {last_name} is {age} years old")

# Output
#
# Joe Schmoe is 23 years old
# Earnst Ehlmann is 65 years old
# Thomas Fischer is 11 years old
# Martin Walter is 36 years old
# Charles Rogan is 83 years old



collections
https://book.pythontips.com/en/latest/collections.html
- defaultdict
- ordereddict
- counter
- deque
- namedtuple
- enum.Enum


intertools
- cartesian product
- permutations 
- combinations
- accumulate
- groupby
- infinite iterators


file operations
https://book.pythontips.com/en/latest/open_function.html

with open('photo.jpg', 'r+') as f:
    jpgdata = f.read()

If you want to read the file, pass in r
If you want to read and write the file, pass in r+
If you want to overwrite the file, pass in w
If you want to append to the file, pass in a



exception handling
https://book.pythontips.com/en/latest/exceptions.html



debugging


## generators ##
lazy iterator that returns one value and ends
used when it's not reasonable store the whole iterator in memory
e.g., large datasets etc.

def get_fib(n):
  a,b = 0,1
  for i in range(n):
    a, b = b, a+b
  yield b

n = 20
for i in range(n+1):
  print(f"{i}: {list(get_fib(i))}")



enumerate
https://book.pythontips.com/en/latest/enumerate.html

data structures
- lists
- tuples
- sets
- dicts

decorators
https://book.pythontips.com/en/latest/decorators.html

function caching
https://book.pythontips.com/en/latest/function_caching.html


context managers
https://book.pythontips.com/en/latest/context_managers.html


queues
consumers and producers

web scraping (beautiful soup)

unit testing
test driven development

multi threading 
multi processing
asyncio

ThreadPoolExecutor
ProcessPoolExecutor

https://stackoverflow.com/questions/27435284/multiprocessing-vs-multithreading-vs-asyncio-in-python-3
https://medium.com/hackernoon/a-simple-introduction-to-pythons-asyncio-595d9c9ecf8c


sockets

webdev
rest API 
flask / django
jinja2 templating

ML/AI
sci-kit / tensorflow

OOP














list1 = [1,2,3,4,5,6,7,8,9]

list2 = list(filter(lambda x: x%2 == 0, list1))
IS SAME AS 
list2 = [*filter(lambda x: x%2 == 0, list1)]

print(list2)


## filter and map will do the interation

## use filter for BOOLEAN return
odds = lambda x: x%2 == 1
list1 = [1,2,3,4,5,6,7,8,9]
list2 = list(filter(odds, list1))
print(list2)

## use map for actual value
sq = lambda x: x ** 2
list1 = [1,2,3,4,5,6,7,8,9]
list2 = list(map(sq, list1))
list2 = list(map(lambda x: x ** 2, list1))
print(list2)

## lambda if boolean
starts_wtih_J = lambda x: True if x.startswith('J') else False


f = lambda x,y: x+y

mx = lambda x,y: x if x > y else y

n = [4,3,2,1]
list(map(lambda x: x**2, n))
OR
print([x**2 for x in n])


n = [4,3,2,1]
list(filter(lambda x: x>2, n))
OR
print([x for x in n if x>2])


from functools import reduce
n = [4,3,2,1]
print(reduce(lambda x,y: x*y, n))


list1 = [1,2,3,4,5,6,7,8,9]
[ x for x in list1 if x%2 == 1 ]
[ x for x in list1 for b in list1 if x%2==0 ]
[ b for x in list1 for b in list1 if x%2==0 ]

[ item for item in list1 if item%2==1 ]


dic1 = {
  "key1": "value1",
  "key2": "value2",
}

{ key:value for (key,value) in dic1.items() }


def f(*args):
  b = 0
  for a in args:
    b += a
  return b

print(f(12,4))


list1 = [1,2,3,4,5,6,7,8,9]
list1 = [1,2,3,4]
from functools import reduce
reduce(lambda x,y: x+y, list1)




# itertools
# product, permutations, combinations, accumulate, groupby, infinite iterators

# cartesian product

'''
from itertools import product

a = [1,2]
b = [3,4]

prod = product(a,b, repeat=2)
print(list(prod))
'''

'''
from itertools import permutations
a = [1,2,3]
perm = permutations(a, 3)
print(list(perm))
'''

'''
from itertools import combinations, combinations_with_replacement
a = [1,2,3,4]
comb = combinations(a,2)
print(list(comb))
comb_wr = combinations_with_replacement(a,2)
print(list(comb_wr))
'''

'''
from itertools import accumulate
import operator
a = [1,2,5,3,4]
# specifying mul it will multiply otherwise default is to add
acc = accumulate(a, func=operator.mul)
# this return the max
acc = accumulate(a, func=max)

print(a)
print(list(acc))
'''

'''
from itertools import groupby
def smaller_than_3(x):
  return x < 3
a = [1,2,3,4]
#group1 = groupby(a, key=smaller_than_3)
group1 = groupby(a, key= lambda x: x<3)
for key, value in group1:
  print(key, list(value))
'''

'''
from itertools import count,cycle,repeat

# infinite loop starts at 1
for i in count(1):
  print(i)

a = [1,2,3,4]
for i in cycle(a):
  print(i)

for i in repeat(1, 4):
  print(i)
'''






















example if you wanted to look for "a" & "b", and "i" & "j"

arr = ['a', 'b', 'x', 'filler', 'y', 'z', 'i', 'j']
your_pairs = [('a', 'b'), ('i', 'j')]

arr = ["NORTH", "SOUTH", "SOUTH", "EAST", "WEST", "NORTH", "WEST"]
your_pairs = [('NORTH', 'SOUTH'), ('SOUTH', 'NORTH'), ('EAST', 'WEST'), ('WEST', 'EAST')]

print([*filter(lambda pair: pair in your_pairs, zip(arr[::2], arr[1::2]))])

print([*filter(lambda pair: pair in your_pairs, arr)])





im gonna break this down from the easy concepts to the harder ones, starting w/ filter
filter is pretty easy to explain
you give it a function & an iterable, and it gives each element of that iterable to the function & then grabs its return
if the bool() of the return value is True, it stays in the filter, otherwise its thrown out
example:
!e
x = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

print(*filter(lambda i: i % 2 == 0, x))

2 4 6 8 10



next im gonna cover zip()
zip() takes any amount of iterables & returns tuples of their indexes, which is pretty hard to word, so ill show you and then explain whats happening
!e
x = [1, 2, 3]
y = [4, 5, 6]

for i in zip(x, y):
  print(i)

001 | (1, 4)
002 | (2, 5)
003 | (3, 6)




okay
next is lambda's, you might alrdy know what they are, but they are anonymous one-liner functions
lambda parameter, parameter2, etc: return_value
they can take parameters as specified on the left side of the colon, and return the stuff on the right
lambda: 1 returns 1 no matter how you call it
lambda i: i*2 returns whatever you give it times 2
pretty simple


def sumof(*args):
  return sum(args)

print(sumof(1, 13, 193, 235, 2, 36, 3, 36, 235))


thats the first use case
the second, which i used, does the opposite
rather than pack everything up
it unpacks everything seperately
what that means is if i can do this:
!e
x = [1, 2, 3, 4, 5, 6]

print(*x)
1 2 3 4 5 6

it takes every element of x and puts them each as seperate arguments to print
unpacking the list as seperate elements
works with anything that has an __iter__ method i believe
lists, tuples, filters, maps






now an explanation of why the combination of all of these concepts works:
[*filter(lambda pair: pair in your_pairs, zip(arr[::2], arr[1::2]))]
first, look at the zip
arr[::2], arr[1::2]
look at what that outputs:
!e
arr = [1, 2, 3, 4, 5, 6]

for i in zip(arr[::2], arr[1::2]):
  print(i)


001 | (1, 2)
002 | (3, 4)
003 | (5, 6)

im taking a slice of all the event numbered indexes & all the odd numbered indexes
and then pairing them together with zip
this is what lets us check our pairs



now look at the lambda
lambda pair: pair in your_pairs
remember, filter passes each element of the iterable into this function
so whats happening is:
!e
arr = [1, 2, 3, 4, 5, 6]
your_pairs = [(1, 2), (4, 6), (5, 6)]

check = lambda pair: pair in your_pairs
for i in zip(arr[::2], arr[1::2]):
  print(check(i))


001 | True
002 | False
003 | True


it checks all the pairs you pass it
and sees if they are in the list of pairs you want
and remember
filter() removes things that dont return a bool() of True



so now you have a filter() object that contains all pairs that are present, make sense?




alright so
one last thing
the reason we put the star there
is because if you didnt:
!e
x = [1, 2, 3, 4, 5, 6, 7]

print(filter(lambda i: i%2==0, x))


<filter object at 0x7f2b115abee0>


the * runs through filter's __iter__ , thereby unpacking it

and since we wrapped it in brackets
it unpacks it into a list
which you can now use



x = [1, 2, 3, 4, 5, 6, 7]
y = [*filter(lambda i: i%2==0, x)]
print(y)
[2, 4, 6]


































